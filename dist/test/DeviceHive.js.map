{"version":3,"sources":["../../src/DeviceHive.js"],"names":["DeviceHive","login","password","serverUrl","token","me","socket","WebSocket","isOpen","isAuthenticated","isTokenRequested","isAuthenticationStarted","addEventListener","Error","messageObject","_getReadyClient","then","action","Promise","resolve","authenticate","reject","requestId","uniqueId","send","JSON","stringify","listener","event","messageData","parse","data","isSuccess","status","removeEventListener","error","once","dispatchEvent","catch","accessToken","refreshToken","onOpen"],"mappings":"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","file":"DeviceHive.js","sourcesContent":["import lodash from \"lodash\";\r\nimport Events from \"./utils/Events\";\r\n\r\n\r\n/**\r\n * DeviceHive api class\r\n */\r\nclass DeviceHive extends Events {\r\n\r\n    /**\r\n     * Creates an instance of DeviceHive.\r\n     * @param {Object} { login, password, serverUrl, token }\r\n     * @memberof DeviceHive\r\n     */\r\n    constructor({ login, password, serverUrl, token }) {\r\n        super();\r\n\r\n        const me = this;\r\n\r\n        if (serverUrl && ((login && password) || token )) {\r\n            me.socket = new WebSocket(serverUrl);\r\n            me.login = login;\r\n            me.password = password;\r\n            me.serverUrl = serverUrl;\r\n            me.token = token;\r\n            me.isOpen = false;\r\n            me.isAuthenticated = false;\r\n            me.isTokenRequested = false;\r\n            me.isAuthenticationStarted = false;\r\n\r\n            me.socket.addEventListener(`open`, () => me.isOpen = true);\r\n            me.socket.addEventListener(`close`, () => me.isOpen = false);\r\n        } else {\r\n            throw new Error(`You need to specify URL, login and password or token`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send message object over WS session by the key\r\n     * @param messageObject\r\n     * @return {Promise}\r\n     */\r\n    send(messageObject) {\r\n        const me = this;\r\n\r\n        return me._getReadyClient()\r\n            .then(() => {\r\n                return me.isAuthenticated === true ||\r\n                    messageObject.action === `authenticate` ||\r\n                    messageObject.action === `token` ?\r\n                    Promise.resolve() : me.authenticate();\r\n            })\r\n            .then(() => new Promise((resolve, reject) => {\r\n                messageObject.requestId = messageObject.requestId || lodash.uniqueId(`deviceHiveId_`);\r\n                me.socket.send(JSON.stringify(messageObject));\r\n\r\n                const listener = (event) => {\r\n                    const messageData = JSON.parse(event.data);\r\n                    const isSuccess = messageData.status === `success`;\r\n\r\n                    if (messageData.action === messageObject.action &&\r\n                        messageData.requestId === messageObject.requestId) {\r\n                        me.socket.removeEventListener(`message`, listener);\r\n                        me.isAuthenticated = isSuccess === false ? isSuccess : me.isAuthenticated;\r\n                        isSuccess ? resolve(messageData) : reject(messageData.error);\r\n                    }\r\n                };\r\n\r\n                me.socket.addEventListener(`message`, listener);\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Internal `authenticate` message sender\r\n     * @param {String} accessToken\r\n     * @memberof DeviceHive\r\n     */\r\n    authenticate({ token, login, password } = {}) {\r\n        const me = this;\r\n\r\n        me.token = token || me.token;\r\n        me.login = login || me.login;\r\n        me.password = password || me.password;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            me.once(`authenticated`, () => {\r\n                me.isTokenRequested = false;\r\n                me.isAuthenticationStarted = false;\r\n                me.isAuthenticated = true;\r\n                resolve();\r\n            });\r\n\r\n            if (me.isAuthenticated === true) {\r\n                me.dispatchEvent(`authenticated`);\r\n            } else {\r\n                if (me.isAuthenticationStarted === false || me.isTokenRequested === false) {\r\n                    if (me.token) {\r\n                        me.isAuthenticationStarted = true;\r\n                        me.send({action: `authenticate`, token: me.token})\r\n                            .then(() => me.dispatchEvent(`authenticated`))\r\n                            .catch((error) => reject(error));\r\n                    } else {\r\n                        me.isTokenRequested = true;\r\n                        me.send({action: `token`, login: me.login, password: me.password})\r\n                            .then(({accessToken, refreshToken}) => me.authenticate({token: accessToken}))\r\n                            .catch((error) => reject(error));\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Waits for WS session to be opened\r\n     * @return {Promise}\r\n     * @private\r\n     */\r\n    _getReadyClient() {\r\n        const me = this;\r\n\r\n        function onOpen(resolve) {\r\n            me.socket.removeEventListener(`open`, onOpen);\r\n            resolve(me)\r\n        }\r\n\r\n        return new Promise((resolve) => me.isOpen ? resolve(me) : me.socket.addEventListener(`open`, () => onOpen(resolve)));\r\n    }\r\n}\r\n\r\n\r\nexport default DeviceHive;"]}