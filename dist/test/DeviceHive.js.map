{"version":3,"sources":["../../src/DeviceHive.js"],"names":["DeviceHive","login","password","serverUrl","token","me","socket","WebSocket","isOpen","isAuthenticated","addEventListener","Error","messageObject","_getReadyClient","then","Promise","resolve","reject","requestId","uniqueId","send","JSON","stringify","listener","event","messageData","parse","data","isSuccess","status","action","removeEventListener","error","accessToken","refreshToken","authenticate","catch","onOpen"],"mappings":"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","file":"DeviceHive.js","sourcesContent":["import lodash from \"lodash\";\r\nimport Events from \"./utils/Events\";\r\n\r\n\r\n/**\r\n * DeviceHive api class\r\n */\r\nclass DeviceHive extends Events {\r\n\r\n    /**\r\n     * Creates an instance of DeviceHive.\r\n     * @param {Object} { login, password, serverUrl, token }\r\n     * @memberof DeviceHive\r\n     */\r\n    constructor({ login, password, serverUrl, token }) {\r\n        super();\r\n\r\n        const me = this;\r\n\r\n        if (serverUrl && ((login && password) || token )) {\r\n            me.socket = new WebSocket(serverUrl);\r\n            me.login = login;\r\n            me.password = password;\r\n            me.serverUrl = serverUrl;\r\n            me.token = token;\r\n            me.isOpen = false;\r\n            me.isAuthenticated = false;\r\n\r\n            me.socket.addEventListener(`open`, () => me.isOpen = true);\r\n            me.socket.addEventListener(`close`, () => me.isOpen = false);\r\n        } else {\r\n            throw new Error(`You need to specify URL, login and password or token`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send message object over WS session by the key\r\n     * @param messageObject\r\n     * @return {Promise}\r\n     */\r\n    send(messageObject) {\r\n        const me = this;\r\n\r\n        return me._getReadyClient()\r\n            .then(() => new Promise((resolve, reject) => {\r\n                messageObject.requestId = messageObject.requestId || lodash.uniqueId(`deviceHiveId_`);\r\n                me.socket.send(JSON.stringify(messageObject));\r\n\r\n                const listener = (event) => {\r\n                    const messageData = JSON.parse(event.data);\r\n                    const isSuccess = messageData.status === `success`;\r\n\r\n                    if (messageData.action === messageObject.action &&\r\n                        messageData.requestId === messageObject.requestId) {\r\n                        me.socket.removeEventListener(`message`, listener);\r\n                        me.isAuthenticated = isSuccess;\r\n                        isSuccess ? resolve(messageData) : reject(messageData.error);\r\n                    }\r\n                };\r\n\r\n                me.socket.addEventListener(`message`, listener);\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Internal `authenticate` message sender\r\n     * @param {String} accessToken\r\n     * @memberof DeviceHive\r\n     */\r\n    authenticate({ token, login, password } = {}) {\r\n        const me = this;\r\n\r\n        me.token = token || me.token;\r\n        me.login = login || me.login;\r\n        me.password = password || me.password;\r\n\r\n        return  me.isAuthenticated ? Promise.resolve() : (me.token ?\r\n            me.send({ action: `authenticate`, token: me.token }) :\r\n            me.send({ action: `token`, login: me.login,  password: me.password })\r\n                .then(({ accessToken, refreshToken }) => me.authenticate({ token: accessToken }))\r\n                .catch(() => me.authenticate({ login: me.login, password: me.password })))\r\n            .then(() => me.isAuthenticated = true );\r\n    }\r\n\r\n    /**\r\n     * Waits for WS session to be opened\r\n     * @return {Promise}\r\n     * @private\r\n     */\r\n    _getReadyClient() {\r\n        const me = this;\r\n\r\n        function onOpen(resolve) {\r\n            me.socket.removeEventListener(`open`, onOpen);\r\n            resolve(me)\r\n        }\r\n\r\n        return new Promise((resolve) => me.isOpen ? resolve(me) : me.socket.addEventListener(`open`, () => onOpen(resolve)));\r\n    }\r\n}\r\n\r\n\r\nexport default DeviceHive;"]}