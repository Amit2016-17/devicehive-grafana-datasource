{"version":3,"sources":["../src/DeviceHive.js"],"names":["lodash","Events","DeviceHive","login","password","serverUrl","token","me","socket","WebSocket","isOpen","isAuthenticated","isTokenRequested","isAuthenticationStarted","addEventListener","Error","messageObject","_getReadyClient","then","action","Promise","resolve","authenticate","reject","requestId","uniqueId","send","JSON","stringify","listener","event","messageData","parse","data","isSuccess","status","removeEventListener","error","once","dispatchEvent","catch","accessToken","refreshToken","onOpen"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAOA,kB;;AACAC,kB;;;;;;;;;;;;;;;;;;;;;AAMDC,sB;;;AAEF;;;;;AAKA,0CAAmD;AAAA,wBAArCC,KAAqC,QAArCA,KAAqC;AAAA,wBAA9BC,QAA8B,QAA9BA,QAA8B;AAAA,wBAApBC,SAAoB,QAApBA,SAAoB;AAAA,wBAATC,KAAS,QAATA,KAAS;;AAAA;;AAAA;;AAG/C,wBAAMC,UAAN;;AAEA,wBAAIF,cAAeF,SAASC,QAAV,IAAuBE,KAArC,CAAJ,EAAkD;AAC9CC,2BAAGC,MAAH,GAAY,IAAIC,SAAJ,CAAcJ,SAAd,CAAZ;AACAE,2BAAGJ,KAAH,GAAWA,KAAX;AACAI,2BAAGH,QAAH,GAAcA,QAAd;AACAG,2BAAGF,SAAH,GAAeA,SAAf;AACAE,2BAAGD,KAAH,GAAWA,KAAX;AACAC,2BAAGG,MAAH,GAAY,KAAZ;AACAH,2BAAGI,eAAH,GAAqB,KAArB;AACAJ,2BAAGK,gBAAH,GAAsB,KAAtB;AACAL,2BAAGM,uBAAH,GAA6B,KAA7B;;AAEAN,2BAAGC,MAAH,CAAUM,gBAAV,SAAmC;AAAA,mCAAMP,GAAGG,MAAH,GAAY,IAAlB;AAAA,yBAAnC;AACAH,2BAAGC,MAAH,CAAUM,gBAAV,UAAoC;AAAA,mCAAMP,GAAGG,MAAH,GAAY,KAAlB;AAAA,yBAApC;AACH,qBAbD,MAaO;AACH,8BAAM,IAAIK,KAAJ,wDAAN;AACH;AApB8C;AAqBlD;;AAED;;;;;;;;;yCAKKC,a,EAAe;AAChB,4BAAMT,KAAK,IAAX;;AAEA,+BAAOA,GAAGU,eAAH,GACFC,IADE,CACG,YAAM;AACR,mCAAOX,GAAGI,eAAH,KAAuB,IAAvB,IACHK,cAAcG,MAAd,mBADG,IAEHH,cAAcG,MAAd,YAFG,GAGHC,QAAQC,OAAR,EAHG,GAGiBd,GAAGe,YAAH,EAHxB;AAIH,yBANE,EAOFJ,IAPE,CAOG;AAAA,mCAAM,IAAIE,OAAJ,CAAY,UAACC,OAAD,EAAUE,MAAV,EAAqB;AACzCP,8CAAcQ,SAAd,GAA0BR,cAAcQ,SAAd,IAA2BxB,OAAOyB,QAAP,iBAArD;AACAlB,mCAAGC,MAAH,CAAUkB,IAAV,CAAeC,KAAKC,SAAL,CAAeZ,aAAf,CAAf;;AAEA,oCAAMa,WAAW,SAAXA,QAAW,CAACC,KAAD,EAAW;AACxB,wCAAMC,cAAcJ,KAAKK,KAAL,CAAWF,MAAMG,IAAjB,CAApB;AACA,wCAAMC,YAAYH,YAAYI,MAAZ,cAAlB;;AAEA,wCAAIJ,YAAYZ,MAAZ,KAAuBH,cAAcG,MAArC,IACAY,YAAYP,SAAZ,KAA0BR,cAAcQ,SAD5C,EACuD;AACnDjB,2CAAGC,MAAH,CAAU4B,mBAAV,YAAyCP,QAAzC;AACAtB,2CAAGI,eAAH,GAAqBuB,cAAc,KAAd,GAAsBA,SAAtB,GAAkC3B,GAAGI,eAA1D;AACAuB,oDAAYb,QAAQU,WAAR,CAAZ,GAAmCR,OAAOQ,YAAYM,KAAnB,CAAnC;AACH;AACJ,iCAVD;;AAYA9B,mCAAGC,MAAH,CAAUM,gBAAV,YAAsCe,QAAtC;AACH,6BAjBW,CAAN;AAAA,yBAPH,CAAP;AAyBH;;;mDAO6C;AAAA,wGAAJ,EAAI;AAAA,4BAA/BvB,KAA+B,SAA/BA,KAA+B;AAAA,4BAAxBH,KAAwB,SAAxBA,KAAwB;AAAA,4BAAjBC,QAAiB,SAAjBA,QAAiB;;AAC1C,4BAAMG,KAAK,IAAX;;AAEAA,2BAAGD,KAAH,GAAWA,SAASC,GAAGD,KAAvB;AACAC,2BAAGJ,KAAH,GAAWA,SAASI,GAAGJ,KAAvB;AACAI,2BAAGH,QAAH,GAAcA,YAAYG,GAAGH,QAA7B;;AAEA,+BAAO,IAAIgB,OAAJ,CAAY,UAACC,OAAD,EAAUE,MAAV,EAAqB;AACpChB,+BAAG+B,IAAH,kBAAyB,YAAM;AAC3B/B,mCAAGK,gBAAH,GAAsB,KAAtB;AACAL,mCAAGM,uBAAH,GAA6B,KAA7B;AACAN,mCAAGI,eAAH,GAAqB,IAArB;AACAU;AACH,6BALD;;AAOA,gCAAId,GAAGI,eAAH,KAAuB,IAA3B,EAAiC;AAC7BJ,mCAAGgC,aAAH;AACH,6BAFD,MAEO;AACH,oCAAIhC,GAAGM,uBAAH,KAA+B,KAA/B,IAAwCN,GAAGK,gBAAH,KAAwB,KAApE,EAA2E;AACvE,wCAAIL,GAAGD,KAAP,EAAc;AACVC,2CAAGM,uBAAH,GAA6B,IAA7B;AACAN,2CAAGmB,IAAH,CAAQ,EAACP,sBAAD,EAAyBb,OAAOC,GAAGD,KAAnC,EAAR,EACKY,IADL,CACU;AAAA,mDAAMX,GAAGgC,aAAH,iBAAN;AAAA,yCADV,EAEKC,KAFL,CAEW,UAACH,KAAD;AAAA,mDAAWd,OAAOc,KAAP,CAAX;AAAA,yCAFX;AAGH,qCALD,MAKO;AACH9B,2CAAGK,gBAAH,GAAsB,IAAtB;AACAL,2CAAGmB,IAAH,CAAQ,EAACP,eAAD,EAAkBhB,OAAOI,GAAGJ,KAA5B,EAAmCC,UAAUG,GAAGH,QAAhD,EAAR,EACKc,IADL,CACU;AAAA,gDAAEuB,WAAF,SAAEA,WAAF;AAAA,gDAAeC,YAAf,SAAeA,YAAf;AAAA,mDAAiCnC,GAAGe,YAAH,CAAgB,EAAChB,OAAOmC,WAAR,EAAhB,CAAjC;AAAA,yCADV,EAEKD,KAFL,CAEW,UAACH,KAAD;AAAA,mDAAWd,OAAOc,KAAP,CAAX;AAAA,yCAFX;AAGH;AACJ;AACJ;AACJ,yBAzBM,CAAP;AA0BH;;;sDAOiB;AACd,4BAAM9B,KAAK,IAAX;;AAEA,iCAASoC,MAAT,CAAgBtB,OAAhB,EAAyB;AACrBd,+BAAGC,MAAH,CAAU4B,mBAAV,SAAsCO,MAAtC;AACAtB,oCAAQd,EAAR;AACH;;AAED,+BAAO,IAAIa,OAAJ,CAAY,UAACC,OAAD;AAAA,mCAAad,GAAGG,MAAH,GAAYW,QAAQd,EAAR,CAAZ,GAA0BA,GAAGC,MAAH,CAAUM,gBAAV,SAAmC;AAAA,uCAAM6B,OAAOtB,OAAP,CAAN;AAAA,6BAAnC,CAAvC;AAAA,yBAAZ,CAAP;AACH;;;;cAvHoBpB,M;;+BA2HVC,U","file":"DeviceHive.js","sourcesContent":["import lodash from \"lodash\";\r\nimport Events from \"./utils/Events\";\r\n\r\n\r\n/**\r\n * DeviceHive api class\r\n */\r\nclass DeviceHive extends Events {\r\n\r\n    /**\r\n     * Creates an instance of DeviceHive.\r\n     * @param {Object} { login, password, serverUrl, token }\r\n     * @memberof DeviceHive\r\n     */\r\n    constructor({ login, password, serverUrl, token }) {\r\n        super();\r\n\r\n        const me = this;\r\n\r\n        if (serverUrl && ((login && password) || token )) {\r\n            me.socket = new WebSocket(serverUrl);\r\n            me.login = login;\r\n            me.password = password;\r\n            me.serverUrl = serverUrl;\r\n            me.token = token;\r\n            me.isOpen = false;\r\n            me.isAuthenticated = false;\r\n            me.isTokenRequested = false;\r\n            me.isAuthenticationStarted = false;\r\n\r\n            me.socket.addEventListener(`open`, () => me.isOpen = true);\r\n            me.socket.addEventListener(`close`, () => me.isOpen = false);\r\n        } else {\r\n            throw new Error(`You need to specify URL, login and password or token`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Send message object over WS session by the key\r\n     * @param messageObject\r\n     * @return {Promise}\r\n     */\r\n    send(messageObject) {\r\n        const me = this;\r\n\r\n        return me._getReadyClient()\r\n            .then(() => {\r\n                return me.isAuthenticated === true ||\r\n                    messageObject.action === `authenticate` ||\r\n                    messageObject.action === `token` ?\r\n                    Promise.resolve() : me.authenticate();\r\n            })\r\n            .then(() => new Promise((resolve, reject) => {\r\n                messageObject.requestId = messageObject.requestId || lodash.uniqueId(`deviceHiveId_`);\r\n                me.socket.send(JSON.stringify(messageObject));\r\n\r\n                const listener = (event) => {\r\n                    const messageData = JSON.parse(event.data);\r\n                    const isSuccess = messageData.status === `success`;\r\n\r\n                    if (messageData.action === messageObject.action &&\r\n                        messageData.requestId === messageObject.requestId) {\r\n                        me.socket.removeEventListener(`message`, listener);\r\n                        me.isAuthenticated = isSuccess === false ? isSuccess : me.isAuthenticated;\r\n                        isSuccess ? resolve(messageData) : reject(messageData.error);\r\n                    }\r\n                };\r\n\r\n                me.socket.addEventListener(`message`, listener);\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Internal `authenticate` message sender\r\n     * @param {String} accessToken\r\n     * @memberof DeviceHive\r\n     */\r\n    authenticate({ token, login, password } = {}) {\r\n        const me = this;\r\n\r\n        me.token = token || me.token;\r\n        me.login = login || me.login;\r\n        me.password = password || me.password;\r\n\r\n        return new Promise((resolve, reject) => {\r\n            me.once(`authenticated`, () => {\r\n                me.isTokenRequested = false;\r\n                me.isAuthenticationStarted = false;\r\n                me.isAuthenticated = true;\r\n                resolve();\r\n            });\r\n\r\n            if (me.isAuthenticated === true) {\r\n                me.dispatchEvent(`authenticated`);\r\n            } else {\r\n                if (me.isAuthenticationStarted === false || me.isTokenRequested === false) {\r\n                    if (me.token) {\r\n                        me.isAuthenticationStarted = true;\r\n                        me.send({action: `authenticate`, token: me.token})\r\n                            .then(() => me.dispatchEvent(`authenticated`))\r\n                            .catch((error) => reject(error));\r\n                    } else {\r\n                        me.isTokenRequested = true;\r\n                        me.send({action: `token`, login: me.login, password: me.password})\r\n                            .then(({accessToken, refreshToken}) => me.authenticate({token: accessToken}))\r\n                            .catch((error) => reject(error));\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Waits for WS session to be opened\r\n     * @return {Promise}\r\n     * @private\r\n     */\r\n    _getReadyClient() {\r\n        const me = this;\r\n\r\n        function onOpen(resolve) {\r\n            me.socket.removeEventListener(`open`, onOpen);\r\n            resolve(me)\r\n        }\r\n\r\n        return new Promise((resolve) => me.isOpen ? resolve(me) : me.socket.addEventListener(`open`, () => onOpen(resolve)));\r\n    }\r\n}\r\n\r\n\r\nexport default DeviceHive;"]}