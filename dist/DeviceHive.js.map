{"version":3,"sources":["../src/DeviceHive.js"],"names":["lodash","DeviceHive","login","password","serverUrl","token","me","socket","WebSocket","isOpen","isAuthenticated","addEventListener","console","warn","Error","messageObject","_getReadyClient","then","Promise","resolve","reject","requestId","uniqueId","send","JSON","stringify","listener","event","messageData","parse","data","action","removeEventListener","status","error","accessToken","refreshToken","authenticate","catch","onOpen"],"mappings":"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","file":"DeviceHive.js","sourcesContent":["import lodash from \"lodash\";\n\n\n/**\n *\n */\nclass DeviceHive {\n\n    /**\n     * Creates an instance of DeviceHive.\n     * @param {Object} { login, password, serverUrl, token }\n     * @memberof DeviceHive\n     */\n    constructor({ login, password, serverUrl, token }) {\n        const me = this;\n\n        if (serverUrl && ((login && password) || token )) {\n            me.socket = new WebSocket(serverUrl);\n            me.login = login;\n            me.password = password;\n            me.serverUrl = serverUrl;\n            me.token = token;\n            me.isOpen = false;\n            me.isAuthenticated = false;\n\n            me.socket.addEventListener(`open`, () => me.isOpen = true);\n            me.socket.addEventListener(`close`, () => me.isOpen = false);\n        } else {\n            console.warn(`You need to specify URL, login and password or token`);\n            throw new Error(`You need to specify URL, login and password or token`);\n        }\n    }\n\n    /**\n     * Send message object over WS session by the key\n     * @param messageObject\n     * @return {Promise}\n     */\n    send(messageObject) {\n        const me = this;\n\n        return me._getReadyClient()\n            .then(() => new Promise((resolve, reject) => {\n                messageObject.requestId = messageObject.requestId || lodash.uniqueId(`deviceHiveId_`);\n                me.socket.send(JSON.stringify(messageObject));\n\n                const listener = (event) => {\n                    const messageData = JSON.parse(event.data);\n\n                    if (messageData.action === messageObject.action &&\n                        messageData.requestId === messageObject.requestId) {\n                        me.socket.removeEventListener(`message`, listener);\n                        me.isAuthenticated = messageData.status === `success`;\n                        messageData.status === `success` ? resolve(messageData) : reject(messageData.error);\n                    }\n                };\n\n                me.socket.addEventListener(`message`, listener);\n            }));\n    }\n\n    /**\n     * Internal `authenticate` message sender\n     *\n     * @param {String} accessToken\n     * @memberof DeviceHive\n     */\n    authenticate({ token, login, password } = {}) {\n        const me = this;\n\n        me.token = token || me.token;\n        me.login = login || me.login;\n        me.password = password || me.password;\n\n        return  me.isAuthenticated ? Promise.resolve() : (me.token ?\n            me.send({ action: `authenticate`, token: me.token }) :\n            me.send({ action: `token`, login: me.login,  password: me.password })\n                .then(({ accessToken, refreshToken }) => me.authenticate({ token: accessToken }))\n                .catch(() => me.authenticate({ login: me.login, password: me.password })))\n            .then(() => me.isAuthenticated = true );\n    }\n\n    /**\n     *\n     * @return {Promise}\n     * @private\n     */\n    _getReadyClient() {\n        const me = this;\n\n        function onOpen(resolve) {\n            me.socket.removeEventListener(`open`, onOpen);\n            resolve(me)\n        }\n\n        return new Promise((resolve) => me.isOpen ? resolve(me) : me.socket.addEventListener(`open`, () => onOpen(resolve)));\n    }\n}\n\n\nexport default DeviceHive;"]}